
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>QA.qa &#8212; SMV Question Matching  documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for QA.qa</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">nltk</span>
<span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="k">import</span> <span class="n">wordnet</span> <span class="k">as</span> <span class="n">wn</span>
<span class="kn">from</span> <span class="nn">nltk.stem.porter</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">question</span> <span class="k">import</span> <span class="n">Question</span><span class="p">,</span> <span class="n">QuestionSet</span><span class="p">,</span> <span class="n">preprocess_db</span><span class="p">,</span> <span class="n">SQLError</span>
<span class="kn">from</span> <span class="nn">nltk.metrics</span> <span class="k">import</span> <span class="n">edit_distance</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="k">import</span> <span class="n">DecisionTreeClassifier</span><span class="p">,</span> <span class="n">export_graphviz</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="k">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.naive_bayes</span> <span class="k">import</span> <span class="n">GaussianNB</span><span class="p">,</span> <span class="n">MultinomialNB</span><span class="p">,</span> <span class="n">BernoulliNB</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">config</span> <span class="k">import</span> <span class="n">smv_cutoffs</span><span class="p">,</span> <span class="n">frog_cutoffs</span><span class="p">,</span> <span class="n">combined_cutoffs</span><span class="p">,</span> <span class="n">tree_model_data</span>


<span class="n">dt</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">min_samples_split</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">52</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Model for decision tree learning/classification&quot;&quot;&quot;</span>

<span class="n">nb_b</span> <span class="o">=</span> <span class="n">BernoulliNB</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;Model for Bernoulli naive bayes learning/classification&quot;&quot;&quot;</span>

<span class="n">nb_g</span> <span class="o">=</span> <span class="n">GaussianNB</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;Model for Gaussian naive bayes learning/classification&quot;&quot;&quot;</span>

<span class="n">cutoffs</span> <span class="o">=</span> <span class="n">combined_cutoffs</span>
<span class="sd">&quot;&quot;&quot;confidence cutoffs for if answer exists or not&quot;&quot;&quot;</span>

<span class="c1">#nb_m = MultinomialNB()</span>


<div class="viewcode-block" id="gen_tree"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.gen_tree">[docs]</a><span class="k">def</span> <span class="nf">gen_tree</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates the tree model data for :any:`QA.qa.dt` based on :any:`QA.config.tree_model_data`. Also generates</span>
<span class="sd">    data for :any:`QA.qa.nb_g` and :any:`QA.qa.nb_b` based on that same data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">dt</span><span class="p">,</span> <span class="n">tree_keys</span><span class="p">,</span> <span class="n">nb_g</span><span class="p">,</span> <span class="n">nb_b</span>
    <span class="n">file</span> <span class="o">=</span> <span class="n">tree_model_data</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="n">tree_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;correct&#39;</span><span class="p">,</span> <span class="s1">&#39;tree_confidence&#39;</span><span class="p">]]</span>
    <span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">Y_train</span><span class="p">,</span> <span class="n">Y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">tree_keys</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;correct&#39;</span><span class="p">],</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">52</span><span class="p">)</span>

    <span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">Y_train</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tree accuracy on test data split: &#39;</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">Y_test</span><span class="p">))</span>

    <span class="n">nb_b</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">Y_train</span><span class="p">)</span>
    <span class="n">nb_g</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">Y_train</span><span class="p">)</span></div>
    <span class="c1">#nb_m.fit(x, y)</span>


<span class="c1"># create the tree</span>
<span class="n">gen_tree</span><span class="p">()</span>
<span class="c1"># initialize the stemmer</span>
<span class="n">stemmer</span> <span class="o">=</span> <span class="n">PorterStemmer</span><span class="p">()</span>



<div class="viewcode-block" id="get_question_sets"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.get_question_sets">[docs]</a><span class="k">def</span> <span class="nf">get_question_sets</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets all preprocessed subjects</span>

<span class="sd">    Returns:</span>
<span class="sd">        generator: all preprocessed subjects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="s1">&#39;./preprocessed&#39;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">file_name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">file_name</span></div>
    <span class="c1">#return get_subjects_from_sql()</span>

<div class="viewcode-block" id="preprocess"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.preprocess">[docs]</a><span class="k">def</span> <span class="nf">preprocess</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Does any necessary preprocessing for qa to start.</span>

<span class="sd">    All this now entails is a call to question.preprocess_db</span>
<span class="sd">    &quot;&quot;&quot;</span>
   
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;preprocessing questions&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">preprocess_db</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">SQLError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;questions processed&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span></div>


<span class="c1"># This is our abstract class for our different matching techniques.</span>
<div class="viewcode-block" id="NLPMethod"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.NLPMethod">[docs]</a><span class="k">class</span> <span class="nc">NLPMethod</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class to extend to create a matching technique.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="NLPMethod.gen_results"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.NLPMethod.gen_results">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">gen_results</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">p_time</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the matches as a dictionary formatted as follows:</span>

<span class="sd">            {</span>
<span class="sd">                &quot;matched&quot;: &lt;question that is the best match, or &quot;No answer matched.&quot;&gt;,</span>

<span class="sd">                &quot;ans&quot;: &lt;answer to best matched question, or &quot;No answer matched.&quot;&gt;,</span>

<span class="sd">                &quot;time&quot;: &lt;time taken to run this method&gt;,</span>

<span class="sd">                &quot;cutoff&quot;: &lt;the cutoff used to determine if a match is actually an answer&gt;,</span>

<span class="sd">                &quot;matches&quot;: [</span>

<span class="sd">                    {&lt;match_prob&gt;, &lt;matched question&gt;</span>

<span class="sd">                        &quot;match&quot;: &lt;match confidence&gt;,</span>

<span class="sd">                        &quot;question&quot;: &lt;matched question&gt;</span>

<span class="sd">                    },</span>
<span class="sd">                    ...</span>
<span class="sd">                ]</span>
<span class="sd">            }</span>

<span class="sd">        the &quot;matches&quot; part of the dictionary is only included if debug is set to True</span>

<span class="sd">        Args:</span>
<span class="sd">            matches (list): list of matches in format ``[(&lt;match_probability&gt;, &lt;Question&gt;), ...]`` sorted by best answer</span>
<span class="sd">                first (highest probability first)</span>
<span class="sd">            p_time (float): time it took to process the results</span>
<span class="sd">            debug (bool): whether to show debug information or not</span>
<span class="sd">            cutoff (float): the cutoff for determining if an answer exists</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: the formatted list of matches</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;matched&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;ans&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;matches&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">p_time</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">matches</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;matched&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;No answer matched.&#39;</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;ans&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;No answer matched.&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;matched&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">question</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;ans&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">answer</span>
            <span class="n">result</span><span class="p">[</span><span class="s1">&#39;cutoff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cutoff</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;matches&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;match&#39;</span><span class="p">:</span> <span class="n">question</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;question&#39;</span><span class="p">:</span> <span class="n">question</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">question</span><span class="p">}</span> <span class="k">for</span> <span class="n">question</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="NLPMethod.run_method"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.NLPMethod.run_method">[docs]</a>    <span class="k">def</span> <span class="nf">run_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="n">top_n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">cutoff</span> <span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs the NLPMethod and determines the best matches, if any</span>

<span class="sd">        Args:</span>
<span class="sd">            question (str): the user question being asked</span>
<span class="sd">            db (QuestionSet): the set of questions to compare against</span>
<span class="sd">            debug (bool): whether or not to return debugging info</span>
<span class="sd">            top_n (int, optional): the amount of results to show in debugging info. Defaults to 5</span>
<span class="sd">            cutoff (float, optional): the cutoff used to determine if a match is actually an answer or not.</span>
<span class="sd">                Defaults to 0, meaning that every match will be considered an answer by default.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: the formatted list of matches, formatted as shown in NLPMethod.gen_results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">db</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">match_prob</span><span class="p">(</span><span class="n">question</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">q</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">sorted</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">NLPMethod</span><span class="o">.</span><span class="n">gen_results</span><span class="p">(</span><span class="n">out</span><span class="p">[:</span><span class="n">top_n</span><span class="p">]</span> <span class="k">if</span> <span class="n">top_n</span> <span class="k">else</span> <span class="n">out</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span></div>

<div class="viewcode-block" id="NLPMethod.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.NLPMethod.match_prob">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the probability that two questions are a match. Abstract method of :class:`QA.qa.NLPMethod`, override in any</span>
<span class="sd">        subclasses.</span>

<span class="sd">        Args:</span>
<span class="sd">            question1 (question.Question): user inputted question</span>
<span class="sd">            question2 (question.Question): the existing question being compared against</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: probability of the questions being a correct match</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>

<div class="viewcode-block" id="get_answer"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.get_answer">[docs]</a><span class="k">def</span> <span class="nf">get_answer</span><span class="p">(</span><span class="n">userQuestion</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">category</span><span class="p">):</span>
    
    <span class="n">result</span> <span class="o">=</span><span class="n">get_response</span><span class="p">(</span><span class="n">userQuestion</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">category</span> <span class="o">==</span> <span class="s2">&quot;frog&quot;</span> <span class="k">else</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="p">[</span><span class="n">method</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1">#[0][&#39;question&#39;]),str(result[&#39;results&#39;][method][&#39;matches&#39;][0][&#39;match&#39;])</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">][</span><span class="n">method</span><span class="p">][</span><span class="s1">&#39;matches&#39;</span><span class="p">]</span></div>


    
<span class="c1"># This was the first technique we developed the probability of a match is</span>
<span class="c1"># the number of significant words the two questions have in common divided</span>
<span class="c1"># by total number of different words between the two questions.</span>
<div class="viewcode-block" id="Exact"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.Exact">[docs]</a><span class="k">class</span> <span class="nc">Exact</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches questions based on shared keywords, only taking exact matches into account.</span>

<span class="sd">    In the sentences &quot;John had a cow&quot; and &quot;John had two cows&quot;, &quot;John&quot; would match, but &quot;cow&quot; would not match &quot;cows&quot;</span>
<span class="sd">    because the words are not exactly the same.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Exact.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.Exact.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">question1</span><span class="o">.</span><span class="n">sig_word_set</span> <span class="o">&amp;</span> <span class="n">question2</span><span class="o">.</span><span class="n">sig_word_set</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">question1</span><span class="o">.</span><span class="n">sig_word_set</span> <span class="o">|</span> <span class="n">question2</span><span class="o">.</span><span class="n">sig_word_set</span><span class="p">)</span></div></div>


<span class="c1"># This technique is similar to the exact technique above. The difference</span>
<span class="c1"># is that this technique takes synonyms of significant words in to account.</span>
<span class="c1"># If a word is an exact match then it counts as 1 for the numerator, if a</span>
<span class="c1"># synonym is a match then it counts as .5 for the numerator.</span>
<div class="viewcode-block" id="SynsetMatch"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SynsetMatch">[docs]</a><span class="k">class</span> <span class="nc">SynsetMatch</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches questions based on shared keywords, taking synonyms into account. A synset is a grouping of all synonyms</span>
<span class="sd">    with a particular definition. Stemming is also taken into account (reducing a word to its base form, so</span>
<span class="sd">    &quot;pancakes&quot; becomes &quot;pancake&quot; and &quot;devouring&quot; becomes &quot;devour&quot;).</span>

<span class="sd">    In the sentences &quot;How much is car insurance&quot; and &quot;How much is automobile insurance&quot;, &quot;car&quot; and &quot;automobile&quot; should</span>
<span class="sd">    match because they are synonyms. The other words should still match as well. The match for the word &quot;insurance&quot;,</span>
<span class="sd">    however, adds more to the similarity score than the match between &quot;car&quot; and &quot;automobile&quot; because it is an exact</span>
<span class="sd">    match.</span>

<span class="sd">    In the sentences &quot;What would a carnivore be eating&quot; and &quot;What do carnivores eat&quot;, &quot;carnivore&quot; matches with</span>
<span class="sd">    &quot;carnivores&quot; because they have the same stem. In addition, &quot;eating&quot; matches with &quot;eat&quot; for the same reason.</span>

<span class="sd">    Synonyms and stems are found using NLTK&#39;s Wordnet corpus.</span>

<span class="sd">    It is important to note that some words might match up with several synsets. &quot;Whale&quot;, for example, matches with the</span>
<span class="sd">    synset for the animal as well as the synset &quot;giant.n.04&quot; (words meaning &quot;a very large person; impressive in size</span>
<span class="sd">    or qualities&quot;). For this NLPMethod, all synsets that match up with a word are checked, meaning it will check</span>
<span class="sd">    against both &quot;giant&quot; and &quot;whale&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SynsetMatch.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SynsetMatch.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="n">match_num</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">for</span> <span class="n">wordTuple</span> <span class="ow">in</span> <span class="n">question1</span><span class="o">.</span><span class="n">sig_words</span><span class="p">:</span>
            <span class="n">match_made</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">matching</span> <span class="ow">in</span> <span class="n">question2</span><span class="o">.</span><span class="n">sig_words</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">match_made</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">wordTuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">matching</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">stemmer</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">wordTuple</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">stemmer</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">matching</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>  <span class="c1"># exact matches count for 1.0</span>
                    <span class="n">match_num</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">match_made</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">match_made</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">wordTuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">matching</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># synset matches count for 0.5</span>
                    <span class="n">match_num</span> <span class="o">+=</span> <span class="mf">0.5</span>
                    <span class="n">match_made</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">match_num</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">question1</span><span class="o">.</span><span class="n">sig_words</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">question2</span><span class="o">.</span><span class="n">sig_words</span><span class="p">)</span> <span class="o">-</span> <span class="n">match_num</span><span class="p">)</span> <span class="c1"># This isn&#39;t actually jacard similarity but eh close enough for right now</span></div></div>


<div class="viewcode-block" id="SynsetPathSimilarity"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SynsetPathSimilarity">[docs]</a><span class="k">class</span> <span class="nc">SynsetPathSimilarity</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compares two questions using path similarity between words. This uses synsets, which are groups of synonyms with the</span>
<span class="sd">    same definition. Synsets are an element of the NLTK Wordnet corpus. In it, there is a tree of all (well, most)</span>
<span class="sd">    synsets in the English language. In this tree, you might have something like the following (which is a real</span>
<span class="sd">    subset of the Wordnet tree):</span>

<span class="sd">    defender.n.01</span>
<span class="sd">        -&gt; fireman.n.04                     \n</span>
<span class="sd">        -&gt; lawman.n.01</span>
<span class="sd">            -&gt; policeman.n.01</span>

<span class="sd">    In this tree, calculating path similarity involves computing the shortest number of edges to get from one synset to</span>
<span class="sd">    another. So in this example tree, &quot;fireman&quot; and &quot;policeman&quot; are close together, and would thus have a higher</span>
<span class="sd">    path similarity than &quot;fireman&quot; and &quot;killer whale&quot; (not shown in this tree because it&#39;s really far away)</span>

<span class="sd">    It is important to note that some words might match up with several synsets. &quot;Whale&quot;, for example, matches with the</span>
<span class="sd">    synset for the animal as well as the synset for &quot;giant&quot; (meaning &quot;a very large person; impressive in size or</span>
<span class="sd">    qualities&quot;). For this NLPMethod, all synsets that match up with a word are checked, meaning it will check</span>
<span class="sd">    against both &quot;giant&quot; and &quot;whale&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SynsetPathSimilarity.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SynsetPathSimilarity.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="n">similarity</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">for</span> <span class="n">wordTuple</span> <span class="ow">in</span> <span class="n">question1</span><span class="o">.</span><span class="n">sig_words</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">matching</span> <span class="ow">in</span> <span class="n">question2</span><span class="o">.</span><span class="n">sig_words</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[</span><span class="n">w1</span><span class="o">.</span><span class="n">path_similarity</span><span class="p">(</span><span class="n">w2</span><span class="p">)</span> <span class="k">for</span> <span class="n">w2</span> <span class="ow">in</span> <span class="n">matching</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">w1</span> <span class="ow">in</span> <span class="n">wordTuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">if</span> <span class="n">t</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">temp</span><span class="p">:</span>
                <span class="n">similarity</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">similarity</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">question1</span><span class="o">.</span><span class="n">sig_words</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">question2</span><span class="o">.</span><span class="n">sig_words</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="SynsetWuPalmerSimilarity"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SynsetWuPalmerSimilarity">[docs]</a><span class="k">class</span> <span class="nc">SynsetWuPalmerSimilarity</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Like :class:`SynsetPathSimilarity`, but with a different kind of similarity called Wu-Palmer Similarity. Wu-Palmer</span>
<span class="sd">    similarity is very similar to Path Similarity, except in the fact that it weights edges in the graph when</span>
<span class="sd">    calculating similarity values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SynsetWuPalmerSimilarity.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SynsetWuPalmerSimilarity.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="n">similarity</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">for</span> <span class="n">wordTuple</span> <span class="ow">in</span> <span class="n">question1</span><span class="o">.</span><span class="n">sig_words</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">matching</span> <span class="ow">in</span> <span class="n">question2</span><span class="o">.</span><span class="n">sig_words</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[</span><span class="n">w1</span><span class="o">.</span><span class="n">wup_similarity</span><span class="p">(</span><span class="n">w2</span><span class="p">)</span> <span class="k">for</span> <span class="n">w2</span> <span class="ow">in</span> <span class="n">matching</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">w1</span> <span class="ow">in</span> <span class="n">wordTuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">if</span> <span class="n">t</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">temp</span><span class="p">:</span>
                <span class="n">similarity</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">similarity</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">question1</span><span class="o">.</span><span class="n">sig_words</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">question2</span><span class="o">.</span><span class="n">sig_words</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="Spacy"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.Spacy">[docs]</a><span class="k">class</span> <span class="nc">Spacy</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This NLPMethod uses SpaCy&#39;s .similarity method. This uses the cosine similarity of word vectors. Honestly we&#39;re not</span>
<span class="sd">    sure exactly how it works, but it seems to be a rather effective way of determining sentence similarity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Spacy.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.Spacy.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">question1</span><span class="o">.</span><span class="n">spacy</span><span class="o">.</span><span class="n">similarity</span><span class="p">(</span><span class="n">question2</span><span class="o">.</span><span class="n">spacy</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SpacyTwo"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SpacyTwo">[docs]</a><span class="k">class</span> <span class="nc">SpacyTwo</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This NLPMethod is the same as the :class:`Spacy` NLPMethod, except it removes all stopwords before doing any</span>
<span class="sd">    processing. Stopwords are common words like &quot;the&quot; or &quot;of&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SpacyTwo.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SpacyTwo.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">question1</span><span class="o">.</span><span class="n">spacy_stop_words</span><span class="o">.</span><span class="n">similarity</span><span class="p">(</span><span class="n">question2</span><span class="o">.</span><span class="n">spacy_stop_words</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SpacyExactAvg"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SpacyExactAvg">[docs]</a><span class="k">class</span> <span class="nc">SpacyExactAvg</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This NLPMethod averages the results from :class:`Spacy` with the results from :class:`Exact`</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SpacyExactAvg.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SpacyExactAvg.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">methods</span><span class="p">[</span><span class="s1">&#39;spacy&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">match_prob</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">)</span> <span class="o">+</span> <span class="n">methods</span><span class="p">[</span><span class="s1">&#39;exact&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">match_prob</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span></div></div>


<div class="viewcode-block" id="SpacyTimesExact"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SpacyTimesExact">[docs]</a><span class="k">class</span> <span class="nc">SpacyTimesExact</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This NLPMethod multiplies the results from :class:`Spacy` with those from :class:`Exact`</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SpacyTimesExact.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SpacyTimesExact.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">methods</span><span class="p">[</span><span class="s1">&#39;spacy&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">match_prob</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">)</span> <span class="o">*</span> <span class="n">methods</span><span class="p">[</span><span class="s1">&#39;exact&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">match_prob</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SpacySynsetAvg"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SpacySynsetAvg">[docs]</a><span class="k">class</span> <span class="nc">SpacySynsetAvg</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This NLPMethod averages the results from :class:`Spacy` and those from :class:`SynsetMatch`</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SpacySynsetAvg.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SpacySynsetAvg.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">methods</span><span class="p">[</span><span class="s1">&#39;spacy&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">match_prob</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">)</span> <span class="o">+</span> <span class="n">methods</span><span class="p">[</span><span class="s1">&#39;synset&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">match_prob</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span></div></div>


<div class="viewcode-block" id="ThreeWayAverage"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.ThreeWayAverage">[docs]</a><span class="k">class</span> <span class="nc">ThreeWayAverage</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This NLPMethod averages the results from :class:`Spacy`, :class:`MostCommonSynsetPathSimilarity` and those from :class:`SynsetMatch`</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ThreeWayAverage.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.ThreeWayAverage.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">methods</span><span class="p">[</span><span class="s1">&#39;spacy&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">match_prob</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">)</span> <span class="o">+</span> <span class="n">methods</span><span class="p">[</span><span class="s1">&#39;synset&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">match_prob</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">)</span> <span class="o">+</span> <span class="n">methods</span><span class="p">[</span><span class="s1">&#39;most_common_synset_path_similarity&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">match_prob</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">))</span><span class="o">/</span><span class="mi">3</span></div></div>

<div class="viewcode-block" id="Distance"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.Distance">[docs]</a><span class="k">class</span> <span class="nc">Distance</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates edit distance between two questions. Edit distance is the amount of changes it takes to get from one</span>
<span class="sd">    string to another. This is the Levenhstein edit distance, which deals with single characters at a time. It does</span>
<span class="sd">    not seem like it&#39;s actually helpful here.</span>

<span class="sd">    match_prob returns the inverse of edit distance so it can still be sorted in descending order (high edit distance =</span>
<span class="sd">    low match probability)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Distance.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.Distance.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">edit_distance</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span></div></div>


<span class="c1"># http://nlpforhackers.io/wordnet-sentence-similarity/</span>
<div class="viewcode-block" id="MostCommonSynsetPathSimilarity"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.MostCommonSynsetPathSimilarity">[docs]</a><span class="k">class</span> <span class="nc">MostCommonSynsetPathSimilarity</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Like :class:`SynsetPathSimilarity`, but only compares the most common Synset for each word instead of checking all possible</span>
<span class="sd">    synsets for a word.</span>

<span class="sd">    Based off of http://nlpforhackers.io/wordnet-sentence-similarity/</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="MostCommonSynsetPathSimilarity.match_prob_oneway"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.MostCommonSynsetPathSimilarity.match_prob_oneway">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob_oneway</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[</span><span class="n">s1</span><span class="o">.</span><span class="n">path_similarity</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">question2</span><span class="o">.</span><span class="n">most_common_synsets</span><span class="p">]</span> <span class="k">if</span> <span class="n">t</span><span class="p">]</span> <span class="ow">or</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">question1</span><span class="o">.</span><span class="n">most_common_synsets</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="k">if</span> <span class="n">temp</span> <span class="k">else</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="MostCommonSynsetPathSimilarity.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.MostCommonSynsetPathSimilarity.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match_prob_oneway</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_prob_oneway</span><span class="p">(</span><span class="n">question2</span><span class="p">,</span> <span class="n">question1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span></div></div>


<div class="viewcode-block" id="MostCommonSynsetWuPalmerSimilarity"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.MostCommonSynsetWuPalmerSimilarity">[docs]</a><span class="k">class</span> <span class="nc">MostCommonSynsetWuPalmerSimilarity</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Like :class:`SynsetWuPalmerSimilarity`, but only compares the most common Synset for each word instead of checking</span>
<span class="sd">    all possible synsets for a word.</span>

<span class="sd">    Based off of http://nlpforhackers.io/wordnet-sentence-similarity/</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="MostCommonSynsetWuPalmerSimilarity.match_prob_oneway"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.MostCommonSynsetWuPalmerSimilarity.match_prob_oneway">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob_oneway</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[</span><span class="n">s1</span><span class="o">.</span><span class="n">wup_similarity</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">question2</span><span class="o">.</span><span class="n">most_common_synsets</span><span class="p">]</span> <span class="k">if</span> <span class="n">t</span><span class="p">]</span> <span class="ow">or</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">question1</span><span class="o">.</span><span class="n">most_common_synsets</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="k">if</span> <span class="n">temp</span> <span class="k">else</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="MostCommonSynsetWuPalmerSimilarity.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.MostCommonSynsetWuPalmerSimilarity.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match_prob_oneway</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_prob_oneway</span><span class="p">(</span><span class="n">question2</span><span class="p">,</span> <span class="n">question1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span></div></div>


<span class="c1"># This technique uses SpaCy to find the set of subjects of both questions.</span>
<span class="c1"># Once the sets have been identified, the probability is the number of</span>
<span class="c1"># words in common between the two sets divided by the total number of words</span>
<span class="c1"># between the two sets.</span>
<div class="viewcode-block" id="SpacySubject"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SpacySubject">[docs]</a><span class="k">class</span> <span class="nc">SpacySubject</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This NLPMethod looks at the subjects of both sentences, as identified by SpaCy, and then returns a score based on</span>
<span class="sd">    if there are any subjects in common.</span>

<span class="sd">    &quot;John ate a banana&quot; and &quot;John went to the store&quot; would return a probability of 1.0 here because &quot;John&quot; is the</span>
<span class="sd">    subject of both. On the other hand, &quot;John ate a banana&quot; and &quot;A banana ate John&quot; would return a probability of 0</span>
<span class="sd">    because the subject of the first sentence is &quot;John&quot; while the subject of the second is &quot;banana&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SpacySubject.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SpacySubject.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        
        <span class="k">global</span> <span class="n">stemmer</span>
        <span class="n">sub1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">stemmer</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">stemmer</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">text</span><span class="p">))</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">question1</span><span class="o">.</span><span class="n">spacy</span> <span class="k">if</span> <span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">dep_</span> <span class="o">==</span> <span class="s2">&quot;nsubj&quot;</span> <span class="ow">or</span> <span class="n">token</span><span class="o">.</span><span class="n">dep_</span> <span class="o">==</span> <span class="s2">&quot;nsubjpass&quot;</span><span class="p">)])</span>
        <span class="n">sub2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">stemmer</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">stemmer</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">text</span><span class="p">))</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">question2</span><span class="o">.</span><span class="n">spacy</span> <span class="k">if</span> <span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">dep_</span> <span class="o">==</span> <span class="s2">&quot;nsubj&quot;</span> <span class="ow">or</span> <span class="n">token</span><span class="o">.</span><span class="n">dep_</span> <span class="o">==</span> <span class="s2">&quot;nsubjpass&quot;</span><span class="p">)])</span>
       

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub1</span> <span class="o">|</span> <span class="n">sub2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">total_matches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub1</span> <span class="o">&amp;</span> <span class="n">sub2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub1</span> <span class="o">|</span> <span class="n">sub2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">total_matches</span></div></div>

<div class="viewcode-block" id="SpacyDirectObject"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SpacyDirectObject">[docs]</a><span class="k">class</span> <span class="nc">SpacyDirectObject</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This NLPMethod looks at the subjects of both sentences, as identified by SpaCy, and then returns a score based on</span>
<span class="sd">    if there are any subjects in common.</span>

<span class="sd">    &quot;John ate a banana&quot; and &quot;John went to the store&quot; would return a probability of 1.0 here because &quot;John&quot; is the</span>
<span class="sd">    subject of both. On the other hand, &quot;John ate a banana&quot; and &quot;A banana ate John&quot; would return a probability of 0</span>
<span class="sd">    because the subject of the first sentence is &quot;John&quot; while the subject of the second is &quot;banana&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SpacyDirectObject.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SpacyDirectObject.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">stemmer</span>
        <span class="n">dobj1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">stemmer</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">question1</span><span class="o">.</span><span class="n">spacy</span> <span class="k">if</span> <span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">dep_</span> <span class="o">==</span> <span class="s2">&quot;dobj&quot;</span><span class="p">)])</span>
        <span class="n">dobj2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">stemmer</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">question2</span><span class="o">.</span><span class="n">spacy</span> <span class="k">if</span> <span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">dep_</span> <span class="o">==</span> <span class="s2">&quot;dobj&quot;</span><span class="p">)])</span>
       

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dobj1</span> <span class="o">|</span> <span class="n">dobj2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">total_matches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dobj1</span> <span class="o">&amp;</span> <span class="n">dobj2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dobj1</span> <span class="o">|</span> <span class="n">dobj2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">total_matches</span></div></div>

<div class="viewcode-block" id="SpacyIndirectObject"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SpacyIndirectObject">[docs]</a><span class="k">class</span> <span class="nc">SpacyIndirectObject</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This NLPMethod looks at the subjects of both sentences, as identified by SpaCy, and then returns a score based on</span>
<span class="sd">    if there are any subjects in common.</span>

<span class="sd">    &quot;John ate a banana&quot; and &quot;John went to the store&quot; would return a probability of 1.0 here because &quot;John&quot; is the</span>
<span class="sd">    subject of both. On the other hand, &quot;John ate a banana&quot; and &quot;A banana ate John&quot; would return a probability of 0</span>
<span class="sd">    because the subject of the first sentence is &quot;John&quot; while the subject of the second is &quot;banana&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SpacyIndirectObject.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.SpacyIndirectObject.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">stemmer</span>

        <span class="n">iobj1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">stemmer</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">question1</span><span class="o">.</span><span class="n">spacy</span> <span class="k">if</span> <span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">dep_</span> <span class="o">==</span> <span class="s2">&quot;pobj&quot;</span><span class="p">)])</span>
        <span class="n">iobj2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">stemmer</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">question2</span><span class="o">.</span><span class="n">spacy</span> <span class="k">if</span> <span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">dep_</span> <span class="o">==</span> <span class="s2">&quot;pobj&quot;</span><span class="p">)])</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iobj1</span> <span class="o">|</span> <span class="n">iobj2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">total_matches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iobj1</span> <span class="o">&amp;</span> <span class="n">iobj2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">iobj1</span> <span class="o">|</span> <span class="n">iobj2</span><span class="p">)</span>
        <span class="c1">#print(total_matches)</span>
        <span class="k">return</span> <span class="n">total_matches</span></div></div>


<div class="viewcode-block" id="DecisionTree"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.DecisionTree">[docs]</a><span class="k">class</span> <span class="nc">DecisionTree</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This NLPMethod uses the decision tree trained in gen_tree to classify all potential matches based on the </span>
<span class="sd">    input queston and questions in the question DB. An issue with this method is that if more than one pair</span>
<span class="sd">    are classified as a match (value = 1) then the match which comes first in the sorted order is selected.</span>

<span class="sd">    Data is trained in :any:`gen_tree`. The model for this decision tree classifier is :any:`QA.qa.dt`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="DecisionTree.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.DecisionTree.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">methods</span><span class="p">[</span><span class="n">k</span><span class="p">[:</span><span class="o">-</span><span class="mi">11</span><span class="p">]]</span><span class="o">.</span><span class="n">match_prob</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tree_keys</span><span class="p">]</span>
        <span class="n">outcome</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">([[</span><span class="n">methods</span><span class="p">[</span><span class="n">k</span><span class="p">[:</span><span class="o">-</span><span class="mi">11</span><span class="p">]]</span><span class="o">.</span><span class="n">match_prob</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tree_keys</span><span class="p">]])[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">outcome</span></div></div>
<div class="viewcode-block" id="NB_B"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.NB_B">[docs]</a><span class="k">class</span> <span class="nc">NB_B</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method uses a Bernoulli Naive Bayes Classifier to predict if the questions are the same or not, based</span>
<span class="sd">    on the same training data used for :class:`DecisionTree` in :any:`gen_tree`. The model for this classifier</span>
<span class="sd">    is :any:`QA.qa.nb_b`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="NB_B.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.NB_B.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">nb_b</span><span class="o">.</span><span class="n">predict</span><span class="p">([[</span><span class="n">methods</span><span class="p">[</span><span class="n">k</span><span class="p">[:</span><span class="o">-</span><span class="mi">11</span><span class="p">]]</span><span class="o">.</span><span class="n">match_prob</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tree_keys</span><span class="p">]])[</span><span class="mi">0</span><span class="p">])</span></div></div>
<div class="viewcode-block" id="NB_G"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.NB_G">[docs]</a><span class="k">class</span> <span class="nc">NB_G</span><span class="p">(</span><span class="n">NLPMethod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method uses a Gaussian Naive Bayes Classifier to predict if the questions are the same or not, based</span>
<span class="sd">    on the same training data used for :class:`DecisionTree` in :any:`gen_tree`. The model for this classifier</span>
<span class="sd">    is :any:`QA.qa.nb_g`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="NB_G.match_prob"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.NB_G.match_prob">[docs]</a>    <span class="k">def</span> <span class="nf">match_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">nb_g</span><span class="o">.</span><span class="n">predict</span><span class="p">([[</span><span class="n">methods</span><span class="p">[</span><span class="n">k</span><span class="p">[:</span><span class="o">-</span><span class="mi">11</span><span class="p">]]</span><span class="o">.</span><span class="n">match_prob</span><span class="p">(</span><span class="n">question1</span><span class="p">,</span> <span class="n">question2</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tree_keys</span><span class="p">]])[</span><span class="mi">0</span><span class="p">])</span></div></div>
<span class="c1">#class NB_M(NLPMethod):</span>
<span class="c1">#    def match_prob(self, question1, question2):</span>
<span class="c1">#        return float(nb_m.predict([[methods[k[:-11]].match_prob(question1, question2) for k in tree_keys]])[0])</span>


<span class="c1"># This is a list of all of the matching techniques described above.</span>
<span class="n">methods</span> <span class="o">=</span> <span class="p">{</span>
           <span class="s2">&quot;tree&quot;</span><span class="p">:</span> <span class="n">DecisionTree</span><span class="p">(),</span>
           <span class="s2">&quot;nb_g&quot;</span><span class="p">:</span> <span class="n">NB_G</span><span class="p">(),</span>
           <span class="s2">&quot;nb_b&quot;</span><span class="p">:</span> <span class="n">NB_B</span><span class="p">(),</span>
            <span class="c1">#&quot;nb_m&quot;: NB_M(),</span>
           <span class="s2">&quot;spacy_synset_average&quot;</span><span class="p">:</span> <span class="n">SpacySynsetAvg</span><span class="p">(),</span>
           <span class="s2">&quot;exact&quot;</span><span class="p">:</span> <span class="n">Exact</span><span class="p">(),</span>
           <span class="s2">&quot;synset&quot;</span><span class="p">:</span> <span class="n">SynsetMatch</span><span class="p">(),</span> 
           <span class="s2">&quot;spacy&quot;</span><span class="p">:</span> <span class="n">Spacy</span><span class="p">(),</span> 
           <span class="c1"># &quot;spacy_without_stopwords&quot;: SpacyTwo(),</span>
           <span class="c1">#&quot;spacy_exact_average&quot;: SpacyExactAvg(), &quot;spacy_times_exact&quot;: SpacyTimesExact(),</span>
            <span class="s2">&quot;most_common_synset_path_similarity&quot;</span><span class="p">:</span> <span class="n">MostCommonSynsetPathSimilarity</span><span class="p">(),</span>
            <span class="s2">&quot;most_common_synset_Wu_Palmer_similarity&quot;</span><span class="p">:</span> <span class="n">MostCommonSynsetWuPalmerSimilarity</span><span class="p">(),</span>
           <span class="c1">#&quot;synset_path_similarity&quot;: SynsetPathSimilarity(), &quot;synset_wu_palmer_similarity&quot;: SynsetWuPalmerSimilarity(),</span>
           <span class="s2">&quot;spacy_subject&quot;</span><span class="p">:</span> <span class="n">SpacySubject</span><span class="p">(),</span> <span class="s2">&quot;spacy_dir_object&quot;</span><span class="p">:</span> <span class="n">SpacyDirectObject</span><span class="p">(),</span>
           <span class="s2">&quot;spacy_ind_object&quot;</span><span class="p">:</span> <span class="n">SpacyIndirectObject</span><span class="p">()</span>
           <span class="c1"># &quot;three_way_average&quot;: ThreeWayAverage()</span>
           <span class="p">}</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This is a dictionary of all matching techniques that the program can use. Keys are what is used to specify what</span>
<span class="sd">    techniques to use, whereas values are instances of the actual technique classes themselves.</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="get_response"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.get_response">[docs]</a><span class="k">def</span> <span class="nf">get_response</span><span class="p">(</span><span class="n">inp_question</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="n">subject</span><span class="p">,</span> <span class="n">top_n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">algorithms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the data for the best possible match given a user question</span>

<span class="sd">    Output format:</span>
<span class="sd">        {</span>
<span class="sd">            &#39;results&#39;: {</span>
<span class="sd">                &lt;method name&gt;: &lt;output from NLPMethod.run_method&gt;,</span>
<span class="sd">                ...</span>
<span class="sd">            },</span>
<span class="sd">            &#39;timers&#39;: {</span>
<span class="sd">                &#39;preprocessingTime&#39;: &lt;time&gt;,\n</span>
<span class="sd">                &#39;processingTime&#39;: &lt;time&gt;,\n</span>
<span class="sd">                &#39;overallTime&#39;: &lt;preprocessingTime + processingTime&gt;</span>
<span class="sd">            },</span>
<span class="sd">            &#39;inp_question&#39;: &lt;user question&gt;</span>
<span class="sd">            &#39;debug&#39;: &lt;debug&gt;</span>
<span class="sd">        }</span>

<span class="sd">    Args:</span>
<span class="sd">        inp_question (str): the user-inputted question</span>
<span class="sd">        debug (bool): whether or not to show debug information</span>
<span class="sd">        subject (int): the subject id to compare the question against</span>
<span class="sd">        top_n (int, optional): the number of results to show in debug information</span>
<span class="sd">        algorithms (list, optional): a list of algorithms to use, as described in the global variable :any:`QA.qa.methods`</span>
<span class="sd">            (Defaults to running all methods)</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: Lots of data regarding the matches found</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;results&#39;</span><span class="p">:</span> <span class="p">{}}</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;timers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">user_question</span> <span class="o">=</span> <span class="n">Question</span><span class="p">(</span><span class="n">inp_question</span><span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;timers&#39;</span><span class="p">][</span><span class="s1">&#39;preprocessingTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">questions</span> <span class="o">=</span> <span class="n">QuestionSet</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="s2">&quot;preprocessed/&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">subject</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">algorithms</span> <span class="k">if</span> <span class="n">algorithms</span> <span class="k">else</span> <span class="n">methods</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">methods</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">continue</span>
        <span class="c1"># result[&#39;results&#39;][a] = methods[a].run_method(user_question, db_questions[subject], debug, top_n)</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">methods</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">run_method</span><span class="p">(</span><span class="n">user_question</span><span class="p">,</span> <span class="n">questions</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="n">top_n</span><span class="p">,</span> <span class="n">cutoffs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cutoffs</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">)</span>

    <span class="c1">#result[&#39;tree_result&#39;] = tree(inp_question, questions, subject)</span>
    <span class="c1">#print(result[&#39;tree_result&#39;])</span>

    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;timers&#39;</span><span class="p">][</span><span class="s1">&#39;processingTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">mid</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;timers&#39;</span><span class="p">][</span><span class="s1">&#39;overallTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;inp_question&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inp_question</span>
    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;debug&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">debug</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="main"><a class="viewcode-back" href="../../docs/source/QA.html#QA.qa.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When qa.py is run on its own, the user can enter a question in the console and see the result with debugging.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">inp_question</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inp_question</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Enter question: &quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">get_response</span><span class="p">(</span><span class="n">inp_question</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)))</span></div>
   

<span class="n">preprocess</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1">#import __init__</span>
    <span class="c1">#__init__.initialize()</span>
    <span class="c1">#__init__.qa.main()</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Zach Brownlow, Christina Mara, Will Rea, Matt Rosenbloom.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>